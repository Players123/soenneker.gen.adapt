using System.Text;

namespace Soenneker.Gen.Adapt.Emitters;

internal static class ReflectionEmitter
{
    /// <summary>
    /// Generates a reflection-based Adapt method as a fallback for when compile-time type information isn't available.
    /// This is used with generic type parameters and abstract base classes.
    /// </summary>
    public static void EmitReflectionAdapter(StringBuilder sb, string targetNamespace)
    {
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Reflection;");
        sb.AppendLine("using System.Collections.Concurrent;");
        sb.AppendLine();
        sb.Append("namespace ").AppendLine(targetNamespace);
        sb.AppendLine("{");
        sb.AppendLine("\tpublic static partial class GenAdapt");
        sb.AppendLine("\t{");
        sb.AppendLine("\t\tprivate static readonly ConcurrentDictionary<(Type Source, Type Dest), Action<object, object>> _reflectionMapperCache = new();");
        sb.AppendLine();
        sb.AppendLine("\t\t/// <summary>");
        sb.AppendLine("\t\t/// Reflection-based fallback adapter for generic type parameters and runtime type resolution.");
        sb.AppendLine("\t\t/// Copies all matching properties from source to destination based on name and assignability.");
        sb.AppendLine("\t\t/// At runtime, TDest will be a concrete type even if the compile-time constraint is abstract.");
        sb.AppendLine("\t\t/// </summary>");
        sb.AppendLine("\t\tpublic static TDest AdaptViaReflection<TDest>(this object source)");
        sb.AppendLine("\t\t{");
        sb.AppendLine("\t\t\tif (source == null)");
        sb.AppendLine("\t\t\t\tthrow new ArgumentNullException(nameof(source));");
        sb.AppendLine();
        sb.AppendLine("\t\t\t// At runtime, typeof(TDest) will be the actual concrete type");
        sb.AppendLine("\t\t\tvar sourceType = source.GetType(); // Get actual runtime type, not compile-time type");
        sb.AppendLine("\t\t\tvar destType = typeof(TDest);");
        sb.AppendLine();
        sb.AppendLine("\t\t\t// Create instance using Activator for concrete types at runtime");
        sb.AppendLine("\t\t\tvar dest = (TDest)Activator.CreateInstance(destType)!;");
        sb.AppendLine();
        sb.AppendLine("\t\t\tvar mapper = _reflectionMapperCache.GetOrAdd((sourceType, destType), key =>");
        sb.AppendLine("\t\t\t{");
        sb.AppendLine("\t\t\t\tvar (srcType, dstType) = key;");
        sb.AppendLine("\t\t\t\tvar destProps = dstType.GetProperties(BindingFlags.Public | BindingFlags.Instance);");
        sb.AppendLine("\t\t\t\tvar actions = new System.Collections.Generic.List<Action<object, object>>();");
        sb.AppendLine();
        sb.AppendLine("\t\t\t\tforeach (var destProp in destProps)");
        sb.AppendLine("\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\tif (!destProp.CanWrite)");
        sb.AppendLine("\t\t\t\t\t\tcontinue;");
        sb.AppendLine();
        sb.AppendLine("\t\t\t\t\tvar sourceProp = srcType.GetProperty(destProp.Name, BindingFlags.Public | BindingFlags.Instance);");
        sb.AppendLine("\t\t\t\t\tif (sourceProp == null || !sourceProp.CanRead)");
        sb.AppendLine("\t\t\t\t\t\tcontinue;");
        sb.AppendLine();
        sb.AppendLine("\t\t\t\t\t// Direct assignment if types are compatible");
        sb.AppendLine("\t\t\t\t\tif (destProp.PropertyType.IsAssignableFrom(sourceProp.PropertyType) || ");
        sb.AppendLine("\t\t\t\t\t    destProp.PropertyType == sourceProp.PropertyType)");
        sb.AppendLine("\t\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\t\tactions.Add((src, dst) =>");
        sb.AppendLine("\t\t\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\t\t\tvar value = sourceProp.GetValue(src);");
        sb.AppendLine("\t\t\t\t\t\t\tdestProp.SetValue(dst, value);");
        sb.AppendLine("\t\t\t\t\t\t});");
        sb.AppendLine("\t\t\t\t\t}");
        sb.AppendLine("\t\t\t\t\t// Handle generic collections (List<T>, IEnumerable<T>, etc.)");
        sb.AppendLine("\t\t\t\t\telse if (sourceProp.PropertyType.IsGenericType && destProp.PropertyType.IsGenericType)");
        sb.AppendLine("\t\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\t\tvar sourceGenericDef = sourceProp.PropertyType.GetGenericTypeDefinition();");
        sb.AppendLine("\t\t\t\t\t\tvar destGenericDef = destProp.PropertyType.GetGenericTypeDefinition();");
        sb.AppendLine();
        sb.AppendLine("\t\t\t\t\t\t// Check if both are List<T> or IEnumerable<T> types");
        sb.AppendLine("\t\t\t\t\t\tif ((sourceGenericDef == typeof(System.Collections.Generic.List<>) || ");
        sb.AppendLine("\t\t\t\t\t\t     sourceGenericDef == typeof(System.Collections.Generic.IEnumerable<>) ||");
        sb.AppendLine("\t\t\t\t\t\t     sourceGenericDef == typeof(System.Collections.Generic.ICollection<>) ||");
        sb.AppendLine("\t\t\t\t\t\t     sourceGenericDef == typeof(System.Collections.Generic.IList<>)) &&");
        sb.AppendLine("\t\t\t\t\t\t    (destGenericDef == typeof(System.Collections.Generic.List<>) ||");
        sb.AppendLine("\t\t\t\t\t\t     destGenericDef == typeof(System.Collections.Generic.IEnumerable<>) ||");
        sb.AppendLine("\t\t\t\t\t\t     destGenericDef == typeof(System.Collections.Generic.ICollection<>) ||");
        sb.AppendLine("\t\t\t\t\t\t     destGenericDef == typeof(System.Collections.Generic.IList<>)))");
        sb.AppendLine("\t\t\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\t\t\tvar sourceItemType = sourceProp.PropertyType.GetGenericArguments()[0];");
        sb.AppendLine("\t\t\t\t\t\t\tvar destItemType = destProp.PropertyType.GetGenericArguments()[0];");
        sb.AppendLine();
        sb.AppendLine("\t\t\t\t\t\t\tactions.Add((src, dst) =>");
        sb.AppendLine("\t\t\t\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\t\t\t\tvar sourceValue = sourceProp.GetValue(src);");
        sb.AppendLine("\t\t\t\t\t\t\t\tif (sourceValue == null)");
        sb.AppendLine("\t\t\t\t\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\t\t\t\t\tdestProp.SetValue(dst, null);");
        sb.AppendLine("\t\t\t\t\t\t\t\t\treturn;");
        sb.AppendLine("\t\t\t\t\t\t\t\t}");
        sb.AppendLine();
        sb.AppendLine("\t\t\t\t\t\t\t\tvar sourceEnumerable = (System.Collections.IEnumerable)sourceValue;");
        sb.AppendLine("\t\t\t\t\t\t\t\tvar destListType = typeof(System.Collections.Generic.List<>).MakeGenericType(destItemType);");
        sb.AppendLine("\t\t\t\t\t\t\t\tvar destList = (System.Collections.IList)Activator.CreateInstance(destListType)!;");
        sb.AppendLine();
        sb.AppendLine("\t\t\t\t\t\t\t\tforeach (var item in sourceEnumerable)");
        sb.AppendLine("\t\t\t\t\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\t\t\t\t\tif (item == null)");
        sb.AppendLine("\t\t\t\t\t\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\t\t\t\t\t\tdestList.Add(null);");
        sb.AppendLine("\t\t\t\t\t\t\t\t\t}");
        sb.AppendLine("\t\t\t\t\t\t\t\t\telse if (destItemType.IsAssignableFrom(sourceItemType) || destItemType == sourceItemType)");
        sb.AppendLine("\t\t\t\t\t\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\t\t\t\t\t\tdestList.Add(item);");
        sb.AppendLine("\t\t\t\t\t\t\t\t\t}");
        sb.AppendLine("\t\t\t\t\t\t\t\t\telse");
        sb.AppendLine("\t\t\t\t\t\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\t\t\t\t\t\t// Recursively adapt nested objects");
        sb.AppendLine("\t\t\t\t\t\t\t\t\t\tvar adaptMethod = typeof(GenAdapt).GetMethod(nameof(AdaptViaReflection));");
        sb.AppendLine("\t\t\t\t\t\t\t\t\t\tvar genericAdaptMethod = adaptMethod!.MakeGenericMethod(destItemType);");
        sb.AppendLine("\t\t\t\t\t\t\t\t\t\tvar adaptedItem = genericAdaptMethod.Invoke(null, new[] { item });");
        sb.AppendLine("\t\t\t\t\t\t\t\t\t\tdestList.Add(adaptedItem);");
        sb.AppendLine("\t\t\t\t\t\t\t\t\t}");
        sb.AppendLine("\t\t\t\t\t\t\t\t}");
        sb.AppendLine();
        sb.AppendLine("\t\t\t\t\t\t\t\tdestProp.SetValue(dst, destList);");
        sb.AppendLine("\t\t\t\t\t\t\t});");
        sb.AppendLine("\t\t\t\t\t\t}");
        sb.AppendLine("\t\t\t\t\t}");
        sb.AppendLine("\t\t\t\t\t// Handle nested complex objects");
        sb.AppendLine("\t\t\t\t\telse if (!sourceProp.PropertyType.IsPrimitive && !destProp.PropertyType.IsPrimitive &&");
        sb.AppendLine("\t\t\t\t\t         sourceProp.PropertyType != typeof(string) && destProp.PropertyType != typeof(string))");
        sb.AppendLine("\t\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\t\tactions.Add((src, dst) =>");
        sb.AppendLine("\t\t\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\t\t\tvar sourceValue = sourceProp.GetValue(src);");
        sb.AppendLine("\t\t\t\t\t\t\tif (sourceValue == null)");
        sb.AppendLine("\t\t\t\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\t\t\t\tdestProp.SetValue(dst, null);");
        sb.AppendLine("\t\t\t\t\t\t\t\treturn;");
        sb.AppendLine("\t\t\t\t\t\t\t}");
        sb.AppendLine();
        sb.AppendLine("\t\t\t\t\t\t\t// Recursively adapt nested object");
        sb.AppendLine("\t\t\t\t\t\t\tvar adaptMethod = typeof(GenAdapt).GetMethod(nameof(AdaptViaReflection));");
        sb.AppendLine("\t\t\t\t\t\t\tvar genericAdaptMethod = adaptMethod!.MakeGenericMethod(destProp.PropertyType);");
        sb.AppendLine("\t\t\t\t\t\t\tvar adaptedValue = genericAdaptMethod.Invoke(null, new[] { sourceValue });");
        sb.AppendLine("\t\t\t\t\t\t\tdestProp.SetValue(dst, adaptedValue);");
        sb.AppendLine("\t\t\t\t\t\t});");
        sb.AppendLine("\t\t\t\t\t}");
        sb.AppendLine("\t\t\t\t}");
        sb.AppendLine();
        sb.AppendLine("\t\t\t\treturn (src, dst) =>");
        sb.AppendLine("\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\tforeach (var action in actions)");
        sb.AppendLine("\t\t\t\t\t\taction(src, dst);");
        sb.AppendLine("\t\t\t\t};");
        sb.AppendLine("\t\t\t});");
        sb.AppendLine();
        sb.AppendLine("\t\t\tmapper(source!, dest!);");
        sb.AppendLine("\t\t\treturn dest;");
        sb.AppendLine("\t\t}");
        sb.AppendLine("\t}");
        sb.AppendLine("}");
    }
}

