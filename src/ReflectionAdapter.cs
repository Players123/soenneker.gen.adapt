using System.Text;

namespace Soenneker.Gen.Adapt;

internal static class ReflectionAdapter
{
    /// <summary>
    /// Generates a reflection-based Adapt method as a fallback for when compile-time type information isn't available.
    /// This is used with generic type parameters and abstract base classes.
    /// </summary>
    public static void EmitReflectionAdapter(StringBuilder sb)
    {
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Reflection;");
        sb.AppendLine("using System.Collections.Concurrent;");
        sb.AppendLine();
        sb.AppendLine("public static partial class GenAdapt");
        sb.AppendLine("{");
        sb.AppendLine("\tprivate static readonly ConcurrentDictionary<(Type Source, Type Dest), Action<object, object>> _reflectionMapperCache = new();");
        sb.AppendLine();
        sb.AppendLine("\t/// <summary>");
        sb.AppendLine("\t/// Reflection-based fallback adapter for generic type parameters and runtime type resolution.");
        sb.AppendLine("\t/// Copies all matching properties from source to destination based on name and assignability.");
        sb.AppendLine("\t/// At runtime, TDest will be a concrete type even if the compile-time constraint is abstract.");
        sb.AppendLine("\t/// </summary>");
        sb.AppendLine("\tpublic static TDest AdaptViaReflection<TSource, TDest>(this TSource source)");
        sb.AppendLine("\t{");
        sb.AppendLine("\t\tif (source == null)");
        sb.AppendLine("\t\t\tthrow new ArgumentNullException(nameof(source));");
        sb.AppendLine();
        sb.AppendLine("\t\t// At runtime, typeof(TDest) will be the actual concrete type");
        sb.AppendLine("\t\tvar sourceType = source.GetType(); // Get actual runtime type, not compile-time type");
        sb.AppendLine("\t\tvar destType = typeof(TDest);");
        sb.AppendLine();
        sb.AppendLine("\t\t// Create instance using Activator for concrete types at runtime");
        sb.AppendLine("\t\tvar dest = (TDest)Activator.CreateInstance(destType)!;");
        sb.AppendLine();
        sb.AppendLine("\t\tvar mapper = _reflectionMapperCache.GetOrAdd((sourceType, destType), key =>");
        sb.AppendLine("\t\t{");
        sb.AppendLine("\t\t\tvar (srcType, dstType) = key;");
        sb.AppendLine("\t\t\tvar destProps = dstType.GetProperties(BindingFlags.Public | BindingFlags.Instance);");
        sb.AppendLine("\t\t\tvar actions = new System.Collections.Generic.List<Action<object, object>>();");
        sb.AppendLine();
        sb.AppendLine("\t\t\tforeach (var destProp in destProps)");
        sb.AppendLine("\t\t\t{");
        sb.AppendLine("\t\t\t\tif (!destProp.CanWrite)");
        sb.AppendLine("\t\t\t\t\tcontinue;");
        sb.AppendLine();
        sb.AppendLine("\t\t\t\tvar sourceProp = srcType.GetProperty(destProp.Name, BindingFlags.Public | BindingFlags.Instance);");
        sb.AppendLine("\t\t\t\tif (sourceProp == null || !sourceProp.CanRead)");
        sb.AppendLine("\t\t\t\t\tcontinue;");
        sb.AppendLine();
        sb.AppendLine("\t\t\t\t// Check if types are compatible");
        sb.AppendLine("\t\t\t\tif (destProp.PropertyType.IsAssignableFrom(sourceProp.PropertyType))");
        sb.AppendLine("\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\tactions.Add((src, dst) =>");
        sb.AppendLine("\t\t\t\t\t{");
        sb.AppendLine("\t\t\t\t\t\tvar value = sourceProp.GetValue(src);");
        sb.AppendLine("\t\t\t\t\t\tdestProp.SetValue(dst, value);");
        sb.AppendLine("\t\t\t\t\t});");
        sb.AppendLine("\t\t\t\t}");
        sb.AppendLine("\t\t\t}");
        sb.AppendLine();
        sb.AppendLine("\t\t\treturn (src, dst) =>");
        sb.AppendLine("\t\t\t{");
        sb.AppendLine("\t\t\t\tforeach (var action in actions)");
        sb.AppendLine("\t\t\t\t\taction(src, dst);");
        sb.AppendLine("\t\t\t};");
        sb.AppendLine("\t\t});");
        sb.AppendLine();
        sb.AppendLine("\t\tmapper(source!, dest!);");
        sb.AppendLine("\t\treturn dest;");
        sb.AppendLine("\t}");
        sb.AppendLine("}");
    }
}

