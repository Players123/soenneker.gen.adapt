using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Text;

namespace Soenneker.Gen.Adapt;

internal static class MapperFile
{
    public static void EmitSourceMapperAndDispatcher(
        StringBuilder sb,
        INamedTypeSymbol source,
        List<INamedTypeSymbol> destinations,
        List<INamedTypeSymbol> enums,
        NameCache names)
    {
        string srcFq = names.FullyQualified(source);
        string srcSan = names.Sanitized(source);

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine();
        sb.AppendLine("public static partial class GenAdapt");
        sb.AppendLine("{");

        // Private mapping methods
        for (int i = 0; i < destinations.Count; i++)
            EmitMappingMethod(sb, source, destinations[i], enums, names);

        // Static readonly delegate fields to avoid allocations
        for (int i = 0; i < destinations.Count; i++)
        {
            INamedTypeSymbol? d = destinations[i];
            string dFq = names.FullyQualified(d);
            string dSan = names.Sanitized(d);
            
            sb.Append("\tprivate static readonly Func<").Append(srcFq).Append(", ").Append(dFq).Append("> _map_")
              .Append(srcSan).Append("_To_").Append(dSan).Append(" = Map_").Append(srcSan).Append("_To_").Append(dSan).AppendLine(";");
        }
        sb.AppendLine();

        // Cache + Dispatcher
        sb.Append("\tprivate static class AdaptCache_").Append(srcSan).AppendLine("<TDest>");
        sb.AppendLine("\t{");
        sb.Append("\t\tpublic static readonly Func<").Append(srcFq).Append(", TDest> Invoke = BuildMapper();").AppendLine();
        sb.AppendLine();
        sb.Append("\t\tprivate static Func<").Append(srcFq).Append(", TDest> BuildMapper()").AppendLine();
        sb.AppendLine("\t\t{");
        sb.AppendLine("\t\t\tvar destType = typeof(TDest);");

        for (int i = 0; i < destinations.Count; i++)
        {
            INamedTypeSymbol? d = destinations[i];
            string dFq = names.FullyQualified(d);
            string dSan = names.Sanitized(d);

            sb.Append("\t\t\tif (destType == typeof(").Append(dFq).AppendLine("))");
            sb.Append("\t\t\t\treturn (Func<").Append(srcFq).Append(", TDest>)(object)_map_")
              .Append(srcSan).Append("_To_").Append(dSan).AppendLine(";");
        }

        sb.AppendLine("\t\t\tthrow new NotSupportedException($\"Unsupported Adapt target type: {destType.FullName}\");");
        sb.AppendLine("\t\t}");
        sb.AppendLine("\t}");
        sb.AppendLine();

        // Public Adapt extension for this source
        sb.AppendLine("\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.Append("\tpublic static TDest Adapt<TDest>(this ").Append(srcFq).AppendLine(" source)");
        sb.AppendLine("\t{");
        sb.Append("\t\treturn AdaptCache_").Append(srcSan).AppendLine("<TDest>.Invoke(source);");
        sb.AppendLine("\t}");
        sb.AppendLine("}");
    }

    private static void EmitMappingMethod(
        StringBuilder sb,
        INamedTypeSymbol source,
        INamedTypeSymbol dest,
        List<INamedTypeSymbol> enums,
        NameCache names)
    {
        // collect props once
        var srcProps = TypeProps.Build(source);
        var dstProps = TypeProps.Build(dest);

        if (dstProps.Settable.Count == 0)
            return;

        string srcFq = names.FullyQualified(source);
        string dstFq = names.FullyQualified(dest);
        string srcSan = names.Sanitized(source);
        string dstSan = names.Sanitized(dest);

        sb.Append("\tprivate static ").Append(dstFq).Append(" Map_").Append(srcSan).Append("_To_").Append(dstSan).Append('(').Append(srcFq).AppendLine(" source)");
        sb.AppendLine("\t{");
        sb.Append("\t\tvar target = new ").Append(dstFq).AppendLine("();");

        // for each destination property, see if a matching source property exists and emit assignment
        for (int i = 0; i < dstProps.Settable.Count; i++)
        {
            Prop dp = dstProps.Settable[i];
            if (!srcProps.TryGet(dp.Name, out Prop sp))
                continue;

            // List-like collections: List<S>, IReadOnlyList<S>, arrays, etc. -> List<D>, arrays, etc.
            if (Types.IsAnyList(sp.Type, out ITypeSymbol? sElem) && Types.IsAnyList(dp.Type, out ITypeSymbol? dElem))
            {
                sb.Append("\t\tif (source.").Append(sp.Name).AppendLine(" is not null)");
                sb.AppendLine("\t\t{");
                
                // Check destination type for special handling
                bool destIsArray = Types.IsArray(dp.Type, out _);
                bool destIsHashSet = Types.IsHashSet(dp.Type, out _) || Types.IsISet(dp.Type, out _);
                
                sb.Append("\t\t\tvar list_").Append(dp.Name).Append(" = new List<").Append(Types.Fq(dElem!)).AppendLine(">();");

                if (SymbolEqualityComparer.Default.Equals(sElem, dElem))
                {
                    sb.Append("\t\t\tforeach (var item in source.").Append(sp.Name).AppendLine(")");
                    sb.Append("\t\t\t\tlist_").Append(dp.Name).AppendLine(".Add(item);");
                }
                else
                {
                    sb.Append("\t\t\tforeach (var item in source.").Append(sp.Name).AppendLine(")");
                    sb.AppendLine("\t\t\t{");
                    string? assn = Assignment.TryBuild("item", sElem!, dElem!, enums);
                    
                    // Special case: string -> Guid uses TryParse
                    if (assn is null && Types.IsString(sElem!) && Types.IsGuid(dElem!))
                    {
                        sb.AppendLine("\t\t\t\tif (global::System.Guid.TryParse(item, out var g))");
                        sb.Append("\t\t\t\t\tlist_").Append(dp.Name).AppendLine(".Add(g);");
                    }
                    else
                    {
                        sb.Append("\t\t\t\tlist_").Append(dp.Name).Append(".Add(").Append(assn ?? "item").AppendLine(");");
                    }
                    sb.AppendLine("\t\t\t}");
                }

                // Convert to appropriate destination type
                if (destIsArray)
                {
                    sb.Append("\t\t\ttarget.").Append(dp.Name).Append(" = list_").Append(dp.Name).AppendLine(".ToArray();");
                }
                else if (destIsHashSet)
                {
                    sb.Append("\t\t\ttarget.").Append(dp.Name).Append(" = new HashSet<").Append(Types.Fq(dElem!)).Append(">(list_").Append(dp.Name).AppendLine(");");
                }
                else
                {
                    sb.Append("\t\t\ttarget.").Append(dp.Name).Append(" = list_").Append(dp.Name).AppendLine(";");
                }
                
                sb.AppendLine("\t\t}");
                continue;
            }

            // Dictionary<K,V1> -> Dictionary<K,V2> with value transformation
            if (Types.IsAnyDictionary(sp.Type, out ITypeSymbol? sKey, out ITypeSymbol? sValue) && 
                Types.IsAnyDictionary(dp.Type, out ITypeSymbol? dKey, out ITypeSymbol? dValue))
            {
                // Keys must match, but values can be different
                if (SymbolEqualityComparer.Default.Equals(sKey, dKey))
                {
                    sb.Append("\t\tif (source.").Append(sp.Name).AppendLine(" is not null)");
                    sb.AppendLine("\t\t{");
                    sb.Append("\t\t\tvar dict_").Append(dp.Name).Append(" = new Dictionary<").Append(Types.Fq(dKey!)).Append(", ").Append(Types.Fq(dValue!)).AppendLine(">();");

                    if (SymbolEqualityComparer.Default.Equals(sValue, dValue))
                    {
                        sb.Append("\t\t\tforeach (var kv in source.").Append(sp.Name).AppendLine(")");
                        sb.Append("\t\t\t\tdict_").Append(dp.Name).AppendLine("[kv.Key] = kv.Value;");
                    }
                    else
                    {
                        sb.Append("\t\t\tforeach (var kv in source.").Append(sp.Name).AppendLine(")");
                        sb.AppendLine("\t\t\t{");
                        string? assn = Assignment.TryBuild("kv.Value", sValue!, dValue!, enums);
                        if (assn is not null)
                        {
                            sb.Append("\t\t\t\tdict_").Append(dp.Name).Append("[kv.Key] = ").Append(assn).AppendLine(";");
                        }
                        sb.AppendLine("\t\t\t}");
                    }

                    sb.Append("\t\t\ttarget.").Append(dp.Name).Append(" = dict_").Append(dp.Name).AppendLine(";");
                    sb.AppendLine("\t\t}");
                    continue;
                }
            }

            string? rhs = Assignment.TryBuild("source." + sp.Name, sp.Type, dp.Type, enums);
            if (rhs is null)
            {
                // Special case: string -> Guid uses TryParse
                if (Types.IsString(sp.Type) && Types.IsGuid(dp.Type))
                {
                    sb.Append("\t\tif (global::System.Guid.TryParse(source.").Append(sp.Name).AppendLine(", out var g))");
                    sb.Append("\t\t\ttarget.").Append(dp.Name).AppendLine(" = g;");
                    continue;
                }
                continue;
            }

            sb.Append("\t\ttarget.").Append(dp.Name).Append(" = ").Append(rhs).AppendLine(";");
        }

        sb.AppendLine("\t\treturn target;");
        sb.AppendLine("\t}");
        sb.AppendLine();
    }
}
