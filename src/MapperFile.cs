using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Soenneker.Gen.Adapt;

internal static class MapperFile
{
    public static void EmitSourceMapperAndDispatcher(
        StringBuilder sb,
        INamedTypeSymbol source,
        List<INamedTypeSymbol> destinations,
        List<INamedTypeSymbol> enums,
        NameCache names,
        string targetNamespace)
    {
        string srcFq = names.FullyQualified(source);
        string srcSan = names.Sanitized(source);

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine();
        sb.Append("namespace ").AppendLine(targetNamespace);
        sb.AppendLine("{");
        sb.AppendLine("\tpublic static partial class GenAdapt");
        sb.AppendLine("\t{");

        if (destinations.Count == 1)
        {
            // Single destination: inline everything directly
            INamedTypeSymbol d = destinations[0];
            string dFq = names.FullyQualified(d);
            
            sb.AppendLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.Append("\t\tpublic static ").Append(dFq).Append(" Adapt(this ").Append(srcFq).AppendLine(" source)");
            sb.AppendLine("\t\t{");
            EmitMappingBody(sb, source, d, enums, names, "\t\t\t");
            sb.AppendLine("\t\t}");
            sb.AppendLine();
            
            // Generic overload (for explicit .Adapt<TDest>() calls)
            sb.AppendLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.Append("\t\tpublic static TDest Adapt<TDest>(this ").Append(srcFq).AppendLine(" source)");
            sb.AppendLine("\t\t{");
            sb.AppendLine("\t\t\treturn (TDest)(object)source.Adapt();");
            sb.AppendLine("\t\t}");
        }
        else
        {
            // Multiple destinations: emit private mapping methods + delegate cache
            for (int i = 0; i < destinations.Count; i++)
                EmitMappingMethod(sb, source, destinations[i], enums, names);
            
            // Static readonly delegate fields
            for (int i = 0; i < destinations.Count; i++)
            {
                INamedTypeSymbol? d = destinations[i];
                string dFq = names.FullyQualified(d);
                string dSan = names.Sanitized(d);
                
                sb.Append("\t\tprivate static readonly Func<").Append(srcFq).Append(", ").Append(dFq).Append("> _map_")
                  .Append(srcSan).Append("_To_").Append(dSan).Append(" = Map_").Append(srcSan).Append("_To_").Append(dSan).AppendLine(";");
            }
            sb.AppendLine();

            sb.Append("\t\tprivate static class AdaptCache_").Append(srcSan).AppendLine("<TDest>");
            sb.AppendLine("\t\t{");
            sb.Append("\t\t\tpublic static readonly Func<").Append(srcFq).Append(", TDest> Invoke = BuildMapper();").AppendLine();
            sb.AppendLine();
            sb.Append("\t\t\tprivate static Func<").Append(srcFq).Append(", TDest> BuildMapper()").AppendLine();
            sb.AppendLine("\t\t\t{");
            sb.AppendLine("\t\t\t\tvar destType = typeof(TDest);");

            for (int i = 0; i < destinations.Count; i++)
            {
                INamedTypeSymbol? d = destinations[i];
                string dFq = names.FullyQualified(d);
                string dSan = names.Sanitized(d);

                sb.Append("\t\t\t\tif (destType == typeof(").Append(dFq).AppendLine("))");
                sb.Append("\t\t\t\t\treturn (Func<").Append(srcFq).Append(", TDest>)(object)_map_")
                  .Append(srcSan).Append("_To_").Append(dSan).AppendLine(";");
            }

            sb.AppendLine("\t\t\t\tthrow new NotSupportedException($\"Unsupported Adapt target type: {destType.FullName}\");");
            sb.AppendLine("\t\t\t}");
            sb.AppendLine("\t\t}");
            sb.AppendLine();

            sb.AppendLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.Append("\t\tpublic static TDest Adapt<TDest>(this ").Append(srcFq).AppendLine(" source)");
            sb.AppendLine("\t\t{");
            sb.Append("\t\t\treturn AdaptCache_").Append(srcSan).AppendLine("<TDest>.Invoke(source);");
            sb.AppendLine("\t\t}");
        }

        sb.AppendLine("\t}");
        sb.AppendLine("}");
    }

    private static bool IsBaseClass(INamedTypeSymbol derived, INamedTypeSymbol potentialBase)
    {
        INamedTypeSymbol? current = derived.BaseType;
        while (current is not null)
        {
            if (SymbolEqualityComparer.Default.Equals(current, potentialBase))
                return true;
            current = current.BaseType;
        }
        return false;
    }

    private static void EmitMappingMethod(
        StringBuilder sb,
        INamedTypeSymbol source,
        INamedTypeSymbol dest,
        List<INamedTypeSymbol> enums,
        NameCache names)
    {
        var srcProps = TypeProps.Build(source);
        var dstProps = TypeProps.Build(dest);

        if (dstProps.Settable.Count == 0)
            return;

        string srcFq = names.FullyQualified(source);
        string dstFq = names.FullyQualified(dest);
        string srcSan = names.Sanitized(source);
        string dstSan = names.Sanitized(dest);

        sb.Append("\t\tprivate static ").Append(dstFq).Append(" Map_").Append(srcSan).Append("_To_").Append(dstSan).Append('(').Append(srcFq).AppendLine(" source)");
        sb.AppendLine("\t\t{");
        
        EmitMappingBody(sb, source, dest, enums, names, "\t\t\t");
        
        sb.AppendLine("\t\t}");
        sb.AppendLine();
    }

    private static void EmitMappingBody(
        StringBuilder sb,
        INamedTypeSymbol source,
        INamedTypeSymbol dest,
        List<INamedTypeSymbol> enums,
        NameCache names,
        string indent)
    {
        // Handle direct collection-to-collection adaptations
        if (Types.IsAnyDictionary(source, out ITypeSymbol? srcKey, out ITypeSymbol? srcValue) && 
            Types.IsAnyDictionary(dest, out ITypeSymbol? dstKey, out ITypeSymbol? dstValue))
        {
            EmitDictionaryMappingBody(sb, source, dest, srcKey!, srcValue!, dstKey!, dstValue!, names, indent);
            return;
        }

        if (Types.IsAnyList(source, out ITypeSymbol? srcElem) && Types.IsAnyList(dest, out ITypeSymbol? dstElem))
        {
            EmitListMappingBody(sb, source, dest, srcElem!, dstElem!, names, indent);
            return;
        }

        // Handle IEnumerable<T> to List<T> adaptations
        if (Types.IsIEnumerable(source, out ITypeSymbol? srcElement) && Types.IsAnyList(dest, out ITypeSymbol? dstElement))
        {
            EmitListMappingBody(sb, source, dest, srcElement!, dstElement!, names, indent);
            return;
        }

        var srcProps = TypeProps.Build(source);
        var dstProps = TypeProps.Build(dest);
        string dstFq = names.FullyQualified(dest);

        // Find required properties and init-only properties
        var requiredPropertyNames = GetRequiredPropertyNames(dest);
        var initOnlyPropertyNames = GetInitOnlyPropertyNames(dest);
        bool hasRequiredProps = requiredPropertyNames.Count > 0;
        bool hasInitOnlyProps = initOnlyPropertyNames.Count > 0;

        // Build list of property mappings
        var simpleMappings = new List<(string propName, string value)>();
        var complexMappings = new List<(Prop dp, Prop sp)>();

        for (int i = 0; i < dstProps.Settable.Count; i++)
        {
            Prop dp = dstProps.Settable[i];
            if (!srcProps.TryGet(dp.Name, out Prop sp))
            {
                // No source property - if required, add default
                if (requiredPropertyNames.Contains(dp.Name))
                {
                    string defaultValue = GetDefaultValueForType(dp.Type);
                    simpleMappings.Add((dp.Name, defaultValue));
                }
                continue;
            }

            // Check if it's a complex type that needs special handling
            bool isComplexType = Types.IsAnyList(sp.Type, out _) || Types.IsAnyDictionary(sp.Type, out _, out _);
            
            if (isComplexType)
            {
                complexMappings.Add((dp, sp));
                continue;
            }

            // Simple property assignment
            string? rhs = Assignment.TryBuild("source." + sp.Name, sp.Type, dp.Type, enums);
            if (rhs is null)
            {
                if (Types.IsString(sp.Type) && Types.IsGuid(dp.Type))
                {
                    // Special case - will handle after object creation
                    complexMappings.Add((dp, sp));
                }
                continue;
            }

            simpleMappings.Add((dp.Name, rhs));
        }

        // Emit object creation
        if (hasRequiredProps || hasInitOnlyProps)
        {
            // Use object initializer syntax for required or init-only properties
            sb.Append(indent).Append("var target = new ").Append(dstFq).AppendLine();
            sb.Append(indent).AppendLine("{");
            for (int i = 0; i < simpleMappings.Count; i++)
            {
                var (propName, value) = simpleMappings[i];
                sb.Append(indent).Append("\t").Append(propName).Append(" = ").Append(value);
                if (i < simpleMappings.Count - 1)
                    sb.AppendLine(",");
                else
                    sb.AppendLine();
            }
            sb.Append(indent).AppendLine("};");
        }
        else
        {
            // Traditional approach
            sb.Append(indent).Append("var target = new ").Append(dstFq).AppendLine("();");
            
            foreach (var (propName, value) in simpleMappings)
            {
                sb.Append(indent).Append("target.").Append(propName).Append(" = ").Append(value).AppendLine(";");
            }
        }

        // Handle complex mappings (lists, dictionaries, special cases)
        foreach (var (dp, sp) in complexMappings)
        {
            if (Types.IsAnyList(sp.Type, out ITypeSymbol? sElem) && Types.IsAnyList(dp.Type, out ITypeSymbol? dElem))
            {
                sb.Append(indent).Append("if (source.").Append(sp.Name).AppendLine(" is not null)");
                sb.Append(indent).AppendLine("{");
                
                bool destIsArray = Types.IsArray(dp.Type, out _);
                bool destIsHashSet = Types.IsHashSet(dp.Type, out _) || Types.IsISet(dp.Type, out _);
                
                sb.Append(indent).Append("\tvar list_").Append(dp.Name).Append(" = new List<").Append(Types.Fq(dElem!)).AppendLine(">();");

                if (SymbolEqualityComparer.Default.Equals(sElem, dElem))
                {
                    sb.Append(indent).Append("\tforeach (var item in source.").Append(sp.Name).AppendLine(")");
                    sb.Append(indent).Append("\t\tlist_").Append(dp.Name).AppendLine(".Add(item);");
                }
                else
                {
                    sb.Append(indent).Append("\tforeach (var item in source.").Append(sp.Name).AppendLine(")");
                    sb.Append(indent).AppendLine("\t{");
                    string? assn = Assignment.TryBuild("item", sElem!, dElem!, enums);
                    
                    if (assn is null && Types.IsString(sElem!) && Types.IsGuid(dElem!))
                    {
                        sb.Append(indent).AppendLine("\t\tif (global::System.Guid.TryParse(item, out var g))");
                        sb.Append(indent).Append("\t\t\tlist_").Append(dp.Name).AppendLine(".Add(g);");
                    }
                    else
                    {
                        sb.Append(indent).Append("\t\tlist_").Append(dp.Name).Append(".Add(").Append(assn ?? "item").AppendLine(");");
                    }
                    sb.Append(indent).AppendLine("\t}");
                }

                if (destIsArray)
                {
                    sb.Append(indent).Append("\ttarget.").Append(dp.Name).Append(" = list_").Append(dp.Name).AppendLine(".ToArray();");
                }
                else if (destIsHashSet)
                {
                    sb.Append(indent).Append("\ttarget.").Append(dp.Name).Append(" = new HashSet<").Append(Types.Fq(dElem!)).Append(">(list_").Append(dp.Name).AppendLine(");");
                }
                else
                {
                    sb.Append(indent).Append("\ttarget.").Append(dp.Name).Append(" = list_").Append(dp.Name).AppendLine(";");
                }
                
                sb.Append(indent).AppendLine("}");
                continue;
            }

            if (Types.IsAnyDictionary(sp.Type, out ITypeSymbol? sKey, out ITypeSymbol? sValue) && 
                Types.IsAnyDictionary(dp.Type, out ITypeSymbol? dKey, out ITypeSymbol? dValue))
            {
                if (SymbolEqualityComparer.Default.Equals(sKey, dKey))
                {
                    // Check if values are same type or source is assignable to dest (upcast)
                    bool sameTypes = SymbolEqualityComparer.Default.Equals(sValue, dValue);
                    bool isAssignable = !sameTypes && sValue is INamedTypeSymbol sNamed && dValue is INamedTypeSymbol dNamed &&
                                       (sNamed.AllInterfaces.Contains(dNamed, SymbolEqualityComparer.Default) ||
                                        IsBaseClass(sNamed, dNamed));
                    
                    if (sameTypes || isAssignable)
                    {
                        sb.Append(indent).Append("if (source.").Append(sp.Name).AppendLine(" is not null)");
                        sb.Append(indent).AppendLine("{");
                        sb.Append(indent).Append("\tvar dict_").Append(dp.Name).Append(" = new Dictionary<").Append(Types.Fq(dKey!)).Append(", ").Append(Types.Fq(dValue!)).AppendLine(">();");
                        sb.Append(indent).Append("\tforeach (var kv in source.").Append(sp.Name).AppendLine(")");
                        sb.Append(indent).Append("\t\tdict_").Append(dp.Name).AppendLine("[kv.Key] = kv.Value;");
                        sb.Append(indent).Append("\ttarget.").Append(dp.Name).Append(" = dict_").Append(dp.Name).AppendLine(";");
                        sb.Append(indent).AppendLine("}");
                        continue;
                    }
                    else
                    {
                        string? assn = Assignment.TryBuild("kv.Value", sValue!, dValue!, enums);
                        if (assn is not null)
                        {
                            sb.Append(indent).Append("if (source.").Append(sp.Name).AppendLine(" is not null)");
                            sb.Append(indent).AppendLine("{");
                            sb.Append(indent).Append("\tvar dict_").Append(dp.Name).Append(" = new Dictionary<").Append(Types.Fq(dKey!)).Append(", ").Append(Types.Fq(dValue!)).AppendLine(">();");
                            sb.Append(indent).Append("\tforeach (var kv in source.").Append(sp.Name).AppendLine(")");
                            sb.Append(indent).AppendLine("\t{");
                            sb.Append(indent).Append("\t\tdict_").Append(dp.Name).Append("[kv.Key] = ").Append(assn).AppendLine(";");
                            sb.Append(indent).AppendLine("\t}");
                            sb.Append(indent).Append("\ttarget.").Append(dp.Name).Append(" = dict_").Append(dp.Name).AppendLine(";");
                            sb.Append(indent).AppendLine("}");
                            continue;
                        }
                    }
                }
            }

            // Special case: string -> Guid with TryParse
            if (Types.IsString(sp.Type) && Types.IsGuid(dp.Type))
            {
                sb.Append(indent).Append("if (global::System.Guid.TryParse(source.").Append(sp.Name).AppendLine(", out var g))");
                sb.Append(indent).Append("\ttarget.").Append(dp.Name).AppendLine(" = g;");
            }
        }

        sb.Append(indent).AppendLine("return target;");
    }

    private static HashSet<string> GetRequiredPropertyNames(INamedTypeSymbol type)
    {
        var result = new HashSet<string>();
        foreach (ISymbol member in type.GetMembers())
        {
            if (member is IPropertySymbol prop && prop.IsRequired)
            {
                result.Add(prop.Name);
            }
        }
        return result;
    }

    private static HashSet<string> GetInitOnlyPropertyNames(INamedTypeSymbol type)
    {
        var result = new HashSet<string>();
        
        // Check all properties including base class properties
        INamedTypeSymbol? current = type;
        while (current is not null)
        {
            foreach (ISymbol member in current.GetMembers())
            {
                if (member is IPropertySymbol prop && prop.SetMethod?.IsInitOnly == true)
                {
                    result.Add(prop.Name);
                }
            }
            current = current.BaseType;
        }
        
        return result;
    }

    private static string GetDefaultValueForType(ITypeSymbol type)
    {
        if (Types.IsString(type))
            return "string.Empty";
        
        if (type.IsValueType)
        {
            if (Types.IsNullableOf(type, out _))
                return "null";
            return "default";
        }
        
        return "null!";
    }

    private static void EmitDictionaryMappingBody(
        StringBuilder sb,
        INamedTypeSymbol source,
        INamedTypeSymbol dest,
        ITypeSymbol sKey,
        ITypeSymbol sValue,
        ITypeSymbol dKey,
        ITypeSymbol dValue,
        NameCache names,
        string indent)
    {
        string dstFq = names.FullyQualified(dest);
        
        sb.Append(indent).Append("var target = new ").Append(dstFq).AppendLine("();");
        
        if (SymbolEqualityComparer.Default.Equals(sKey, dKey) && SymbolEqualityComparer.Default.Equals(sValue, dValue))
        {
            // Same types - direct copy
            sb.Append(indent).Append("foreach (var kv in source)").AppendLine();
            sb.Append(indent).Append("\ttarget[kv.Key] = kv.Value;").AppendLine();
        }
        else
        {
            // Different types - need conversion
            sb.Append(indent).Append("foreach (var kv in source)").AppendLine();
            sb.Append(indent).AppendLine("{");
            
            string keyExpr = SymbolEqualityComparer.Default.Equals(sKey, dKey) 
                ? "kv.Key" 
                : GetConversionExpression("kv.Key", sKey, dKey);
                
            string valueExpr = SymbolEqualityComparer.Default.Equals(sValue, dValue) 
                ? "kv.Value" 
                : GetConversionExpression("kv.Value", sValue, dValue);
                
            sb.Append(indent).Append("\ttarget[").Append(keyExpr).Append("] = ").Append(valueExpr).AppendLine(";");
            sb.Append(indent).AppendLine("}");
        }
        
        sb.Append(indent).AppendLine("return target;");
    }

    private static void EmitListMappingBody(
        StringBuilder sb,
        INamedTypeSymbol source,
        INamedTypeSymbol dest,
        ITypeSymbol sElem,
        ITypeSymbol dElem,
        NameCache names,
        string indent)
    {
        string dstFq = names.FullyQualified(dest);
        
        sb.Append(indent).Append("var target = new ").Append(dstFq).AppendLine("();");
        
        if (SymbolEqualityComparer.Default.Equals(sElem, dElem))
        {
            // Same types - direct copy
            sb.Append(indent).Append("foreach (var item in source)").AppendLine();
            sb.Append(indent).Append("\ttarget.Add(item);").AppendLine();
        }
        else
        {
            // Different types - need conversion
            sb.Append(indent).Append("foreach (var item in source)").AppendLine();
            sb.Append(indent).AppendLine("{");
            
            string itemExpr = GetConversionExpression("item", sElem, dElem);
            sb.Append(indent).Append("\ttarget.Add(").Append(itemExpr).AppendLine(");");
            sb.Append(indent).AppendLine("}");
        }
        
        sb.Append(indent).AppendLine("return target;");
    }

    private static string GetConversionExpression(string expr, ITypeSymbol fromType, ITypeSymbol toType)
    {
        // Handle basic type conversions
        if (SymbolEqualityComparer.Default.Equals(fromType, toType))
            return expr;
            
        // Handle enum conversions
        if (fromType.TypeKind == TypeKind.Enum && Types.IsString(toType))
            return expr + ".ToString()";
            
        if (Types.IsString(fromType) && toType.TypeKind == TypeKind.Enum)
            return "GenAdapt_EnumParsers.Parse_" + San((INamedTypeSymbol)toType) + "(" + expr + ")";
            
        if (fromType.TypeKind == TypeKind.Enum && Types.IsInt(toType))
            return "(int)" + expr;
            
        if (Types.IsInt(fromType) && toType.TypeKind == TypeKind.Enum)
            return "(" + Types.Fq(toType) + ")" + expr;
            
        // Handle Guid conversions
        if (Types.IsGuid(fromType) && Types.IsString(toType))
            return expr + ".ToString()";
            
        if (Types.IsString(fromType) && Types.IsGuid(toType))
            return "global::System.Guid.TryParse(" + expr + ", out var g) ? g : default(global::System.Guid)";
            
        // Handle nullable conversions
        if (Types.IsNullableOf(fromType, out ITypeSymbol? fromInner) && Types.IsNullableOf(toType, out ITypeSymbol? toInner))
        {
            if (SymbolEqualityComparer.Default.Equals(fromInner!, toInner!))
                return expr; // same nullable type
        }
        
        // Handle user-defined type conversions
        if (fromType is INamedTypeSymbol fromNamed && toType is INamedTypeSymbol toNamed &&
            (fromNamed.TypeKind == TypeKind.Class || fromNamed.TypeKind == TypeKind.Struct) &&
            (toNamed.TypeKind == TypeKind.Class || toNamed.TypeKind == TypeKind.Struct) &&
            !Types.IsFrameworkType(fromNamed) && !Types.IsFrameworkType(toNamed))
        {
            return expr + ".Adapt<" + Types.Fq(toType) + ">()";
        }
        
        // Default: cast
        return "(" + Types.Fq(toType) + ")" + expr;
    }

    private static string San(INamedTypeSymbol type)
    {
        // Simple sanitization for enum parser names
        return type.Name.Replace(".", "_").Replace("`", "_");
    }
}
