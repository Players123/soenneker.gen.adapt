using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Text;

namespace Soenneker.Gen.Adapt;

internal static class MapperFile
{
    public static void EmitSourceMapperAndDispatcher(
        StringBuilder sb,
        INamedTypeSymbol source,
        List<INamedTypeSymbol> destinations,
        List<INamedTypeSymbol> enums,
        NameCache names)
    {
        string srcFq = names.FullyQualified(source);
        string srcSan = names.Sanitized(source);

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine();
        sb.AppendLine("public static partial class GenAdapt");
        sb.AppendLine("{");

        // Private mapping methods
        for (int i = 0; i < destinations.Count; i++)
            EmitMappingMethod(sb, source, destinations[i], enums, names);

        // Static readonly delegate fields to avoid allocations
        for (int i = 0; i < destinations.Count; i++)
        {
            INamedTypeSymbol? d = destinations[i];
            string dFq = names.FullyQualified(d);
            string dSan = names.Sanitized(d);
            
            sb.Append("\tprivate static readonly Func<").Append(srcFq).Append(", ").Append(dFq).Append("> _map_")
              .Append(srcSan).Append("_To_").Append(dSan).Append(" = Map_").Append(srcSan).Append("_To_").Append(dSan).AppendLine(";");
        }
        sb.AppendLine();

        // Cache + Dispatcher
        sb.Append("\tprivate static class AdaptCache_").Append(srcSan).AppendLine("<TDest>");
        sb.AppendLine("\t{");
        sb.Append("\t\tpublic static readonly Func<").Append(srcFq).Append(", TDest> Invoke = BuildMapper();").AppendLine();
        sb.AppendLine();
        sb.Append("\t\tprivate static Func<").Append(srcFq).Append(", TDest> BuildMapper()").AppendLine();
        sb.AppendLine("\t\t{");
        sb.AppendLine("\t\t\tvar destType = typeof(TDest);");

        for (int i = 0; i < destinations.Count; i++)
        {
            INamedTypeSymbol? d = destinations[i];
            string dFq = names.FullyQualified(d);
            string dSan = names.Sanitized(d);

            sb.Append("\t\t\tif (destType == typeof(").Append(dFq).AppendLine("))");
            sb.Append("\t\t\t\treturn (Func<").Append(srcFq).Append(", TDest>)(object)_map_")
              .Append(srcSan).Append("_To_").Append(dSan).AppendLine(";");
        }

        sb.AppendLine("\t\t\tthrow new NotSupportedException($\"Unsupported Adapt target type: {destType.FullName}\");");
        sb.AppendLine("\t\t}");
        sb.AppendLine("\t}");
        sb.AppendLine();

        // Public Adapt extension for this source
        sb.AppendLine("\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.Append("\tpublic static TDest Adapt<TDest>(this ").Append(srcFq).AppendLine(" source)");
        sb.AppendLine("\t{");
        sb.Append("\t\treturn AdaptCache_").Append(srcSan).AppendLine("<TDest>.Invoke(source);");
        sb.AppendLine("\t}");
        sb.AppendLine("}");
    }

    private static void EmitMappingMethod(
        StringBuilder sb,
        INamedTypeSymbol source,
        INamedTypeSymbol dest,
        List<INamedTypeSymbol> enums,
        NameCache names)
    {
        // collect props once
        var srcProps = TypeProps.Build(source);
        var dstProps = TypeProps.Build(dest);

        if (dstProps.Settable.Count == 0)
            return;

        string srcFq = names.FullyQualified(source);
        string dstFq = names.FullyQualified(dest);
        string srcSan = names.Sanitized(source);
        string dstSan = names.Sanitized(dest);

        sb.Append("\tprivate static ").Append(dstFq).Append(" Map_").Append(srcSan).Append("_To_").Append(dstSan).Append('(').Append(srcFq).AppendLine(" source)");
        sb.AppendLine("\t{");
        sb.Append("\t\tvar target = new ").Append(dstFq).AppendLine("();");

        // for each destination property, see if a matching source property exists and emit assignment
        for (int i = 0; i < dstProps.Settable.Count; i++)
        {
            Prop dp = dstProps.Settable[i];
            if (!srcProps.TryGet(dp.Name, out Prop sp))
                continue;

            // List<S> -> List<D>
            if (Types.IsList(sp.Type, out ITypeSymbol? sElem) && Types.IsList(dp.Type, out ITypeSymbol? dElem))
            {
                sb.Append("\t\tif (source.").Append(sp.Name).AppendLine(" is not null)");
                sb.AppendLine("\t\t{");
                sb.Append("\t\t\tvar list_").Append(dp.Name).Append(" = new List<").Append(Types.Fq(dElem!)).Append(">(source.").Append(sp.Name).AppendLine(".Count);");

                if (SymbolEqualityComparer.Default.Equals(sElem, dElem))
                {
                    sb.Append("\t\t\tfor (int i2 = 0; i2 < source.").Append(sp.Name).AppendLine(".Count; i2++)");
                    sb.Append("\t\t\t\tlist_").Append(dp.Name).Append(".Add(source.").Append(sp.Name).AppendLine("[i2]);");
                }
                else
                {
                    sb.Append("\t\t\tfor (int i2 = 0; i2 < source.").Append(sp.Name).AppendLine(".Count; i2++)");
                    sb.AppendLine("\t\t\t{");
                    sb.Append("\t\t\t\tvar item = source.").Append(sp.Name).AppendLine("[i2];");
                    string? assn = Assignment.TryBuild("item", sElem!, dElem!, enums);
                    
                    // Special case: string -> Guid uses TryParse
                    if (assn is null && Types.IsString(sElem!) && Types.IsGuid(dElem!))
                    {
                        sb.AppendLine("\t\t\t\tif (global::System.Guid.TryParse(item, out var g))");
                        sb.Append("\t\t\t\t\tlist_").Append(dp.Name).AppendLine(".Add(g);");
                    }
                    else
                    {
                        sb.Append("\t\t\t\tlist_").Append(dp.Name).Append(".Add(").Append(assn ?? "item").AppendLine(");");
                    }
                    sb.AppendLine("\t\t\t}");
                }

                sb.Append("\t\t\ttarget.").Append(dp.Name).Append(" = list_").Append(dp.Name).AppendLine(";");
                sb.AppendLine("\t\t}");
                continue;
            }

            string? rhs = Assignment.TryBuild("source." + sp.Name, sp.Type, dp.Type, enums);
            if (rhs is null)
            {
                // Special case: string -> Guid uses TryParse
                if (Types.IsString(sp.Type) && Types.IsGuid(dp.Type))
                {
                    sb.Append("\t\tif (global::System.Guid.TryParse(source.").Append(sp.Name).AppendLine(", out var g))");
                    sb.Append("\t\t\ttarget.").Append(dp.Name).AppendLine(" = g;");
                    continue;
                }
                continue;
            }

            sb.Append("\t\ttarget.").Append(dp.Name).Append(" = ").Append(rhs).AppendLine(";");
        }

        sb.AppendLine("\t\treturn target;");
        sb.AppendLine("\t}");
        sb.AppendLine();
    }
}
