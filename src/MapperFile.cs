using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Text;

namespace Soenneker.Gen.Adapt;

internal static class MapperFile
{
    public static void EmitSourceMapperAndDispatcher(
        StringBuilder sb,
        INamedTypeSymbol source,
        List<INamedTypeSymbol> destinations,
        List<INamedTypeSymbol> enums,
        NameCache names,
        string targetNamespace,
        Dictionary<INamedTypeSymbol, HashSet<INamedTypeSymbol>>? referencedPairs = null)
    {
        string srcFq = names.FullyQualified(source);
        string srcSan = names.Sanitized(source);

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Runtime.InteropServices;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using System.Diagnostics.CodeAnalysis;");
        sb.AppendLine("using System.CodeDom.Compiler;");
        sb.AppendLine();
        sb.Append("namespace ").AppendLine(targetNamespace);
        sb.AppendLine("{");
        sb.AppendLine("\tpublic static partial class GenAdapt");
        sb.AppendLine("\t{");

        if (destinations.Count == 1)
        {
            // Single destination: emit private Map_* method and have public Adapt forward to it
            INamedTypeSymbol d = destinations[0];
            string dFq = names.FullyQualified(d);
            string dstSan = names.Sanitized(d);

            // Determine if this source->dest mapping is referenced by other mappings (nested usage)
            bool isReferencedByOthers = referencedPairs != null
                && referencedPairs.TryGetValue(source, out var destSet)
                && destSet.Contains(d);

            if (isReferencedByOthers)
            {
                // Private map method only when other sources may call it
                sb.AppendLine("\t\t[GeneratedCode(\"Soenneker.Gen.Adapt\", \"3.0.0\")] ");
                sb.AppendLine("\t\t[ExcludeFromCodeCoverage]");
                sb.AppendLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
                bool _srcIsStruct = source.TypeKind == TypeKind.Struct;
                sb.Append("\t\tprivate static ").Append(dFq).Append(" Map_").Append(srcSan).Append("_To_").Append(dstSan).Append('(');
                if (_srcIsStruct) sb.Append("in ");
                sb.Append(srcFq).AppendLine(" source)");
                sb.AppendLine("\t\t{");
                EmitMappingBody(sb, source, d, enums, names, "\t\t\t");
                sb.AppendLine("\t\t}");
                sb.AppendLine();
            }

            // Public Adapt wrapper (non-generic, single destination)
            sb.AppendLine("\t\t[GeneratedCode(\"Soenneker.Gen.Adapt\", \"3.0.0\")] ");
            sb.AppendLine("\t\t[ExcludeFromCodeCoverage]");
            sb.AppendLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.Append("\t\tpublic static ").Append(dFq).Append(" Adapt(this ").Append(srcFq).AppendLine(" source)");
            sb.AppendLine("\t\t{");
            if (isReferencedByOthers)
            {
                if (source.TypeKind == TypeKind.Struct)
                    sb.Append("\t\t\treturn Map_").Append(srcSan).Append("_To_").Append(dstSan).AppendLine("(in source);");
                else
                    sb.Append("\t\t\treturn Map_").Append(srcSan).Append("_To_").Append(dstSan).AppendLine("(source);");
            }
            else
                EmitMappingBody(sb, source, d, enums, names, "\t\t\t");
            sb.AppendLine("\t\t}");
            sb.AppendLine();

            // Generic overload (for explicit .Adapt<TDest>() calls)
            sb.AppendLine("\t\t[GeneratedCode(\"Soenneker.Gen.Adapt\", \"3.0.0\")] ");
            sb.AppendLine("\t\t[ExcludeFromCodeCoverage]");
            sb.AppendLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.Append("\t\tpublic static TDest Adapt<TDest>(this ").Append(srcFq).AppendLine(" source)");
            sb.AppendLine("\t\t{");
            sb.AppendLine("\t\t\treturn (TDest)(object)source.Adapt();");
            sb.AppendLine("\t\t}");
        }
        else
        {
            // Multiple destinations: emit private mapping methods + per-TDest id cache with switch dispatch
            for (int i = 0; i < destinations.Count; i++)
                EmitMappingMethod(sb, source, destinations[i], enums, names);

            // Enum for dispatch ids (unique per source)
            sb.Append("\t\tprivate enum _MapId_").Append(srcSan).AppendLine();
            sb.AppendLine("\t\t{");
            for (int i = 0; i < destinations.Count; i++)
            {
                INamedTypeSymbol? d = destinations[i];
                string dSan = names.Sanitized(d);
                sb.Append("\t\t\t").Append(dSan).Append(',').AppendLine();
            }
            sb.AppendLine("\t\t\tUnknown");
            sb.AppendLine("\t\t}");
            sb.AppendLine();

            

            // Closed-generic cache for map id
            sb.Append("\t\tprivate static class _MapIdCache_").Append(srcSan).AppendLine("<TDest>");
            sb.AppendLine("\t\t{");
            sb.Append("\t\t\tpublic static readonly _MapId_").Append(srcSan).Append(" Id = ").AppendLine();
            for (int i = 0; i < destinations.Count; i++)
            {
                INamedTypeSymbol? d = destinations[i];
                string dFq = names.FullyQualified(d);
                string dSan = names.Sanitized(d);
                sb.Append("\t\t\t\ttypeof(TDest) == typeof(").Append(dFq).Append(") ? _MapId_").Append(srcSan).Append('.').Append(dSan).Append(" :").AppendLine();
            }
            sb.Append("\t\t\t\t").Append("_MapId_").Append(srcSan).AppendLine(".Unknown;");
            sb.AppendLine("\t\t}");
            sb.AppendLine();

            // Wrapper that switches on cached id; JIT can inline chosen arm
            sb.AppendLine("\t\t[GeneratedCode(\"Soenneker.Gen.Adapt\", \"3.0.0\")] ");
            sb.AppendLine("\t\t[ExcludeFromCodeCoverage]");
            sb.AppendLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
            sb.Append("\t\tpublic static TDest Adapt<TDest>(this ").Append(srcFq).AppendLine(" source)");
            sb.AppendLine("\t\t{");
            sb.Append("\t\t\tswitch (_MapIdCache_").Append(srcSan).AppendLine("<TDest>.Id)");
            sb.AppendLine("\t\t\t{");
            for (int i = 0; i < destinations.Count; i++)
            {
                INamedTypeSymbol? d = destinations[i];
                string dSan = names.Sanitized(d);
                sb.Append("\t\t\t\tcase _MapId_").Append(srcSan).Append('.').Append(dSan).AppendLine(":");
                if (source.TypeKind == TypeKind.Struct)
                    sb.Append("\t\t\t\t\treturn (TDest)(object)Map_").Append(srcSan).Append("_To_").Append(dSan).AppendLine("(in source);");
                else
                    sb.Append("\t\t\t\t\treturn (TDest)(object)Map_").Append(srcSan).Append("_To_").Append(dSan).AppendLine("(source);");
            }
            sb.AppendLine("\t\t\t\tdefault:");
            sb.AppendLine("\t\t\t\t\tthrow new NotSupportedException($\"Unsupported Adapt target type: {typeof(TDest).FullName}\");");
            sb.AppendLine("\t\t\t}");
            sb.AppendLine("\t\t}");
        }

        sb.AppendLine("\t}");
        sb.AppendLine("}");
    }

    private static bool IsBaseClass(INamedTypeSymbol derived, INamedTypeSymbol potentialBase)
    {
        INamedTypeSymbol? current = derived.BaseType;
        while (current is not null)
        {
            if (SymbolEqualityComparer.Default.Equals(current, potentialBase))
                return true;
            current = current.BaseType;
        }
        return false;
    }

    private static void EmitMappingMethod(
        StringBuilder sb,
        INamedTypeSymbol source,
        INamedTypeSymbol dest,
        List<INamedTypeSymbol> enums,
        NameCache names)
    {
        var srcProps = TypeProps.Build(source);
        var dstProps = TypeProps.Build(dest);

        if (dstProps.Settable.Count == 0)
            return;

        string srcFq = names.FullyQualified(source);
        string dstFq = names.FullyQualified(dest);
        string srcSan = names.Sanitized(source);
        string dstSan = names.Sanitized(dest);

        sb.AppendLine("\t\t[GeneratedCode(\"Soenneker.Gen.Adapt\", \"3.0.0\")] ");
        sb.AppendLine("\t\t[ExcludeFromCodeCoverage]");
        sb.AppendLine("\t\t[MethodImpl(MethodImplOptions.AggressiveInlining)]");
        bool _srcIsStruct2 = source.TypeKind == TypeKind.Struct;
        sb.Append("\t\tprivate static ").Append(dstFq).Append(" Map_").Append(srcSan).Append("_To_").Append(dstSan).Append('(');
        if (_srcIsStruct2) sb.Append("in ");
        sb.Append(srcFq).AppendLine(" source)");
        sb.AppendLine("\t\t{");
        
        EmitMappingBody(sb, source, dest, enums, names, "\t\t\t");
        
        sb.AppendLine("\t\t}");
        sb.AppendLine();
    }

    private static void EmitMappingBody(
        StringBuilder sb,
        INamedTypeSymbol source,
        INamedTypeSymbol dest,
        List<INamedTypeSymbol> enums,
        NameCache names,
        string indent)
    {
        // Handle direct collection-to-collection adaptations
        if (Types.IsAnyDictionary(source, out ITypeSymbol? srcKey, out ITypeSymbol? srcValue) && 
            Types.IsAnyDictionary(dest, out ITypeSymbol? dstKey, out ITypeSymbol? dstValue))
        {
            EmitDictionaryMappingBody(sb, source, dest, srcKey!, srcValue!, dstKey!, dstValue!, names, indent);
            return;
        }

        if (Types.IsAnyList(source, out ITypeSymbol? srcElem) && Types.IsAnyList(dest, out ITypeSymbol? dstElem))
        {
            EmitListMappingBody(sb, source, dest, srcElem!, dstElem!, names, indent);
            return;
        }

        // Handle IEnumerable<T> to List<T> adaptations
        if (Types.IsIEnumerable(source, out ITypeSymbol? srcElement) && Types.IsAnyList(dest, out ITypeSymbol? dstElement))
        {
            EmitListMappingBody(sb, source, dest, srcElement!, dstElement!, names, indent);
            return;
        }

        var srcProps = TypeProps.Build(source);
        var dstProps = TypeProps.Build(dest);
        string dstFq = names.FullyQualified(dest);

        // Find required properties and init-only properties
        HashSet<string> requiredPropertyNames = GetRequiredPropertyNames(dest);
        HashSet<string> initOnlyPropertyNames = GetInitOnlyPropertyNames(dest);
        bool hasRequiredProps = requiredPropertyNames.Count > 0;
        bool hasInitOnlyProps = initOnlyPropertyNames.Count > 0;

        // Build list of property mappings
        var simpleMappings = new List<(string propName, string value)>();
        var complexMappings = new List<(Prop dp, Prop sp)>();

        for (int i = 0; i < dstProps.Settable.Count; i++)
        {
            Prop dp = dstProps.Settable[i];
            if (!srcProps.TryGet(dp.Name, out Prop sp))
            {
                // No source property - if required, add default
                if (requiredPropertyNames.Contains(dp.Name))
                {
                    string defaultValue = GetDefaultValueForType(dp.Type);
                    simpleMappings.Add((dp.Name, defaultValue));
                }
                continue;
            }

            // Check if it's a complex type that needs special handling
            bool isComplexType = Types.IsAnyList(sp.Type, out _) || Types.IsAnyDictionary(sp.Type, out _, out _);
            
            if (isComplexType)
            {
                complexMappings.Add((dp, sp));
                continue;
            }

            // Simple property assignment
            string? rhs = Assignment.TryBuild("source." + sp.Name, sp.Type, dp.Type, enums);
            if (rhs is null)
            {
                // Check if it's a nested object that needs mapping
                if (sp.Type is INamedTypeSymbol srcNamed && dp.Type is INamedTypeSymbol dstNamed &&
                    (srcNamed.TypeKind == TypeKind.Class || srcNamed.TypeKind == TypeKind.Struct) &&
                    (dstNamed.TypeKind == TypeKind.Class || dstNamed.TypeKind == TypeKind.Struct) &&
                    !Types.IsFrameworkType(srcNamed) && !Types.IsFrameworkType(dstNamed) &&
                    !SymbolEqualityComparer.Default.Equals(srcNamed, dstNamed))
                {
                    // This is a nested object that needs mapping
                    complexMappings.Add((dp, sp));
                }
                else if (Types.IsString(sp.Type) && Types.IsGuid(dp.Type))
                {
                    // Special case - will handle after object creation
                    complexMappings.Add((dp, sp));
                }
                continue;
            }

            simpleMappings.Add((dp.Name, rhs));
        }

        // Emit object creation
        if (hasRequiredProps || hasInitOnlyProps)
        {
            // Use object initializer syntax for required or init-only properties
            sb.Append(indent).Append("var target = new ").Append(dstFq).AppendLine();
            sb.Append(indent).AppendLine("{");
            for (int i = 0; i < simpleMappings.Count; i++)
            {
                (string propName, string value) = simpleMappings[i];
                sb.Append(indent).Append("\t").Append(propName).Append(" = ").Append(value);
                if (i < simpleMappings.Count - 1)
                    sb.AppendLine(",");
                else
                    sb.AppendLine();
            }
            sb.Append(indent).AppendLine("};");
        }
        else
        {
            // Traditional approach
            sb.Append(indent).Append("var target = new ").Append(dstFq).AppendLine("();");
            
            foreach ((string propName, string value) in simpleMappings)
            {
                sb.Append(indent).Append("target.").Append(propName).Append(" = ").Append(value).AppendLine(";");
            }
        }

        // Handle complex mappings (lists, dictionaries, special cases)
        foreach ((Prop dp, Prop sp) in complexMappings)
        {
            if (Types.IsAnyList(sp.Type, out ITypeSymbol? sElem) && Types.IsAnyList(dp.Type, out ITypeSymbol? dElem))
            {
                sb.Append(indent).Append("if (source.").Append(sp.Name).AppendLine(" is not null)");
                sb.Append(indent).AppendLine("{");
                
                bool destIsArray = Types.IsArray(dp.Type, out _);
                bool destIsHashSet = Types.IsHashSet(dp.Type, out _) || Types.IsISet(dp.Type, out _);

                bool srcIsArray = Types.IsArray(sp.Type, out _);
                bool elementsEqual = SymbolEqualityComparer.Default.Equals(sElem, dElem);

                if (destIsArray)
                {
                    if (srcIsArray && elementsEqual)
                    {
                        // Zero-copy aliasing for array->array with identical element types
                        sb.Append(indent).Append("\ttarget.").Append(dp.Name).Append(" = ").Append("source.").Append(sp.Name).AppendLine(";");
                    }
                    else if (srcIsArray)
                    {
                        sb.Append(indent).Append("\tint n_").Append(dp.Name).Append(" = ").Append("source.").Append(sp.Name).AppendLine(".Length;");
                        sb.Append(indent).Append("\tvar a_").Append(dp.Name).Append(" = new ").Append(Types.Fq(dElem!)).AppendLine("[n_" + dp.Name + "];");
                        sb.Append(indent).AppendLine("\tfor (int i = 0; i < n_" + dp.Name + "; i++)");
                        string? assnArr = Assignment.TryBuild("source." + sp.Name + "[i]", sElem!, dElem!, enums) ?? ("source." + sp.Name + "[i]");
                        sb.Append(indent).Append("\t\ta_").Append(dp.Name).Append("[i] = ").Append(assnArr).AppendLine(";");
                        sb.Append(indent).Append("\ttarget.").Append(dp.Name).Append(" = a_").Append(dp.Name).AppendLine(";");
                    }
                    else
                    {
                        // Non-array to array: pre-materialize via list then ToArray as fallback
                        sb.Append(indent).Append("\tvar list_").Append(dp.Name).Append(" = new List<").Append(Types.Fq(dElem!)).AppendLine(")();");
                        sb.Append(indent).Append("\tforeach (var item in source.").Append(sp.Name).AppendLine(")");
                        string? assn = Assignment.TryBuild("item", sElem!, dElem!, enums) ?? "item";
                        sb.Append(indent).Append("\t\tlist_").Append(dp.Name).Append(".Add(").Append(assn).AppendLine(");");
                        sb.Append(indent).Append("\ttarget.").Append(dp.Name).Append(" = list_").Append(dp.Name).AppendLine(".ToArray();");
                    }
                }
                else
                {
                    // Dest is not array
                    if (srcIsArray && elementsEqual)
                    {
                        // Array->List<T> can use the copying ctor
                        if (!destIsHashSet)
                        {
                            sb.Append(indent)
                              .Append("\ttarget.")
                              .Append(dp.Name)
                              .Append(" = new List<")
                              .Append(Types.Fq(dElem!))
                              .Append(">(source.")
                              .Append(sp.Name)
                              .AppendLine(");");
                        }
                        else
                        {
                            sb.Append(indent)
                              .Append("\ttarget.")
                              .Append(dp.Name)
                              .Append(" = new HashSet<")
                              .Append(Types.Fq(dElem!))
                              .Append(">(source.")
                              .Append(sp.Name)
                              .AppendLine(");");
                        }
                    }
                    else
                    {
                        // Build list using the most efficient traversal available
                        bool srcIsListProp = Types.IsList(sp.Type, out _);
                        bool srcIsROListProp = Types.IsIReadOnlyList(sp.Type, out _);
                        bool srcIsIListProp = Types.IsIList(sp.Type, out _);
                        bool srcHasCount = srcIsArray || srcIsListProp || srcIsROListProp || srcIsIListProp || Types.IsIReadOnlyCollection(sp.Type, out _) || Types.IsICollection(sp.Type, out _);
                        if (srcHasCount)
                        {
                            if (srcIsArray)
                                sb.Append(indent).Append("\tint count_").Append(dp.Name).Append(" = ").Append("source.").Append(sp.Name).AppendLine(".Length;");
                            else
                                sb.Append(indent).Append("\tint count_").Append(dp.Name).Append(" = ").Append("source.").Append(sp.Name).AppendLine(".Count;");
                            sb.Append(indent).Append("\tvar list_").Append(dp.Name).Append(" = new List<").Append(Types.Fq(dElem!)).Append(">(count_").Append(dp.Name).AppendLine(");");
                        }
                        else
                        {
                            sb.Append(indent).Append("\tvar list_").Append(dp.Name).Append(" = new List<").Append(Types.Fq(dElem!)).AppendLine(">(0);");
                        }
                        if (srcIsArray)
                        {
                            sb.Append(indent).AppendLine("\tfor (int i = 0; i < (" + ("source." + sp.Name) + ").Length; i++)");
                            string? assn = Assignment.TryBuild("source." + sp.Name + "[i]", sElem!, dElem!, enums) ?? ("source." + sp.Name + "[i]");
                            sb.Append(indent).Append("\t\tlist_").Append(dp.Name).Append(".Add(").Append(assn).AppendLine(");");
                        }
                        else if (srcIsListProp)
                        {
                            sb.Append(indent).Append("\tvar span_").Append(dp.Name).Append(" = global::System.Runtime.InteropServices.CollectionsMarshal.AsSpan(source.").Append(sp.Name).AppendLine(");");
                            sb.Append(indent).AppendLine("\tfor (int i = 0; i < span_" + dp.Name + ".Length; i++)");
                            sb.Append(indent).AppendLine("\t{");
                            sb.Append(indent).Append("\t\tref readonly var s = ref span_").Append(dp.Name).AppendLine("[i];");
                            string? assn = Assignment.TryBuild("s", sElem!, dElem!, enums) ?? "s";
                            sb.Append(indent).Append("\t\tlist_").Append(dp.Name).Append(".Add(").Append(assn).AppendLine(");");
                            sb.Append(indent).AppendLine("\t}");
                        }
                        else if (srcIsROListProp || srcIsIListProp)
                        {
                            sb.Append(indent).AppendLine("\tfor (int i = 0; i < count_" + dp.Name + "; i++)");
                            string? assn = Assignment.TryBuild("source." + sp.Name + "[i]", sElem!, dElem!, enums) ?? ("source." + sp.Name + "[i]");
                            sb.Append(indent).Append("\t\tlist_").Append(dp.Name).Append(".Add(").Append(assn).AppendLine(");");
                        }
                        else
                        {
                            sb.Append(indent).Append("\tforeach (var item in source.").Append(sp.Name).AppendLine(")");
                            string? assn = Assignment.TryBuild("item", sElem!, dElem!, enums) ?? "item";
                            sb.Append(indent).Append("\t\tlist_").Append(dp.Name).Append(".Add(").Append(assn).AppendLine(");");
                        }

                        if (destIsHashSet)
                        {
                            sb.Append(indent).Append("\ttarget.").Append(dp.Name).Append(" = new HashSet<").Append(Types.Fq(dElem!)).Append(">(list_").Append(dp.Name).AppendLine(");");
                        }
                        else
                        {
                            sb.Append(indent).Append("\ttarget.").Append(dp.Name).Append(" = list_").Append(dp.Name).AppendLine(";");
                        }
                    }
                }
                
                sb.Append(indent).AppendLine("}");
                continue;
            }

            if (Types.IsAnyDictionary(sp.Type, out ITypeSymbol? sKey, out ITypeSymbol? sValue) && 
                Types.IsAnyDictionary(dp.Type, out ITypeSymbol? dKey, out ITypeSymbol? dValue))
            {
                if (SymbolEqualityComparer.Default.Equals(sKey, dKey))
                {
                    // Check if values are same type or source is assignable to dest (upcast)
                    bool sameTypes = SymbolEqualityComparer.Default.Equals(sValue, dValue);
                    bool isAssignable = !sameTypes && sValue is INamedTypeSymbol sNamed && dValue is INamedTypeSymbol dNamed &&
                                       (sNamed.AllInterfaces.Contains(dNamed, SymbolEqualityComparer.Default) ||
                                        IsBaseClass(sNamed, dNamed));
                    
                    if (sameTypes || isAssignable)
                    {
                        sb.Append(indent).Append("if (source.").Append(sp.Name).AppendLine(" is not null)");
                        sb.Append(indent).AppendLine("{");
                        sb.Append(indent).Append("\tvar dict_").Append(dp.Name).Append(" = new Dictionary<").Append(Types.Fq(dKey!)).Append(", ").Append(Types.Fq(dValue!)).Append(">(source.").Append(sp.Name).AppendLine(".Count);");
                        sb.Append(indent).Append("\tforeach (var kv in source.").Append(sp.Name).AppendLine(")");
                        sb.Append(indent).Append("\t\tdict_").Append(dp.Name).AppendLine("[kv.Key] = kv.Value;");
                        sb.Append(indent).Append("\ttarget.").Append(dp.Name).Append(" = dict_").Append(dp.Name).AppendLine(";");
                        sb.Append(indent).AppendLine("}");
                        continue;
                    }
                    else
                    {
                        string? assn = Assignment.TryBuild("kv.Value", sValue!, dValue!, enums);
                        if (assn is not null)
                        {
                            sb.Append(indent).Append("if (source.").Append(sp.Name).AppendLine(" is not null)");
                            sb.Append(indent).AppendLine("{");
                            sb.Append(indent).Append("\tvar dict_").Append(dp.Name).Append(" = new Dictionary<").Append(Types.Fq(dKey!)).Append(", ").Append(Types.Fq(dValue!)).Append(">(source.").Append(sp.Name).AppendLine(".Count);");
                            sb.Append(indent).Append("\tforeach (var kv in source.").Append(sp.Name).AppendLine(")");
                            sb.Append(indent).AppendLine("\t{");
                            sb.Append(indent).Append("\t\tdict_").Append(dp.Name).Append("[kv.Key] = ").Append(assn).AppendLine(";");
                            sb.Append(indent).AppendLine("\t}");
                            sb.Append(indent).Append("\ttarget.").Append(dp.Name).Append(" = dict_").Append(dp.Name).AppendLine(";");
                            sb.Append(indent).AppendLine("}");
                            continue;
                        }
                    }
                }
            }

            // Handle nested object mappings
            if (sp.Type is INamedTypeSymbol srcNamed && dp.Type is INamedTypeSymbol dstNamed &&
                (srcNamed.TypeKind == TypeKind.Class || srcNamed.TypeKind == TypeKind.Struct) &&
                (dstNamed.TypeKind == TypeKind.Class || dstNamed.TypeKind == TypeKind.Struct) &&
                !Types.IsFrameworkType(srcNamed) && !Types.IsFrameworkType(dstNamed) &&
                !SymbolEqualityComparer.Default.Equals(srcNamed, dstNamed))
            {
                sb.Append(indent).Append("if (source.").Append(sp.Name).AppendLine(" is not null)");
                sb.Append(indent).AppendLine("{");
                string srcSanLocal = names.Sanitized(srcNamed);
                string dstSanLocal = names.Sanitized(dstNamed);
                if (srcNamed.TypeKind == TypeKind.Struct)
                {
                    sb.Append(indent).Append("\ttarget.").Append(dp.Name).Append(" = Map_").Append(srcSanLocal).Append("_To_").Append(dstSanLocal).Append("(")
                      .Append("in source.").Append(sp.Name).AppendLine(");");
                }
                else
                {
                    sb.Append(indent).Append("\ttarget.").Append(dp.Name).Append(" = Map_").Append(srcSanLocal).Append("_To_").Append(dstSanLocal).Append("(")
                      .Append("source.").Append(sp.Name).AppendLine(");");
                }
                sb.Append(indent).AppendLine("}");
                continue;
            }

            // Special case: string -> Guid with TryParse
            if (Types.IsString(sp.Type) && Types.IsGuid(dp.Type))
            {
                sb.Append(indent).Append("if (global::System.Guid.TryParse(source.").Append(sp.Name).AppendLine(", out var g))");
                sb.Append(indent).Append("\ttarget.").Append(dp.Name).AppendLine(" = g;");
            }
        }

        sb.Append(indent).AppendLine("return target;");
    }

    private static HashSet<string> GetRequiredPropertyNames(INamedTypeSymbol type)
    {
        var result = new HashSet<string>();
        foreach (ISymbol member in type.GetMembers())
        {
            if (member is IPropertySymbol prop && prop.IsRequired)
            {
                result.Add(prop.Name);
            }
        }
        return result;
    }

    private static HashSet<string> GetInitOnlyPropertyNames(INamedTypeSymbol type)
    {
        var result = new HashSet<string>();
        
        // Check all properties including base class properties
        INamedTypeSymbol? current = type;
        while (current is not null)
        {
            foreach (ISymbol member in current.GetMembers())
            {
                if (member is IPropertySymbol prop && prop.SetMethod?.IsInitOnly == true)
                {
                    result.Add(prop.Name);
                }
            }
            current = current.BaseType;
        }
        
        return result;
    }

    private static string GetDefaultValueForType(ITypeSymbol type)
    {
        if (Types.IsString(type))
            return "string.Empty";
        
        if (type.IsValueType)
        {
            if (Types.IsNullableOf(type, out _))
                return "null";
            return "default";
        }
        
        return "null!";
    }

    private static void EmitDictionaryMappingBody(
        StringBuilder sb,
        INamedTypeSymbol source,
        INamedTypeSymbol dest,
        ITypeSymbol sKey,
        ITypeSymbol sValue,
        ITypeSymbol dKey,
        ITypeSymbol dValue,
        NameCache names,
        string indent)
    {
        string dstFq = names.FullyQualified(dest);
        
        sb.Append(indent).Append("if (source is null || source.Count == 0)").AppendLine();
        sb.Append(indent).Append("\treturn new ").Append(dstFq).AppendLine("();");
        sb.AppendLine();
        sb.Append(indent).Append("var target = new ").Append(dstFq).AppendLine("(source.Count);");
        
        if (SymbolEqualityComparer.Default.Equals(sKey, dKey) && SymbolEqualityComparer.Default.Equals(sValue, dValue))
        {
            // Same types - direct copy
            sb.Append(indent).Append("foreach (var kv in source)").AppendLine();
            sb.Append(indent).Append("\ttarget[kv.Key] = kv.Value;").AppendLine();
        }
        else
        {
            // Different types - need conversion
            sb.Append(indent).Append("foreach (var kv in source)").AppendLine();
            sb.Append(indent).AppendLine("{");
            
            string keyExpr = SymbolEqualityComparer.Default.Equals(sKey, dKey) 
                ? "kv.Key" 
                : GetConversionExpression("kv.Key", sKey, dKey, names);
                
            string valueExpr = SymbolEqualityComparer.Default.Equals(sValue, dValue) 
                ? "kv.Value" 
                : GetConversionExpression("kv.Value", sValue, dValue, names);
                
            sb.Append(indent).Append("\ttarget[").Append(keyExpr).Append("] = ").Append(valueExpr).AppendLine(";");
            sb.Append(indent).AppendLine("}");
        }
        
        sb.Append(indent).AppendLine("return target;");
    }

    private static void EmitListMappingBody(
        StringBuilder sb,
        INamedTypeSymbol source,
        INamedTypeSymbol dest,
        ITypeSymbol sElem,
        ITypeSymbol dElem,
        NameCache names,
        string indent)
    {
        string dstFq = names.FullyQualified(dest);
        
        bool srcIsList = Types.IsList(source, out _);
        bool srcIsArray = Types.IsArray(source, out _);
        bool srcIsROList = Types.IsIReadOnlyList(source, out _);
        bool srcIsIList = Types.IsIList(source, out _);

        if (srcIsList)
        {
            sb.Append(indent).Append("if (source is null || source.Count == 0)").AppendLine();
            sb.Append(indent).Append("\treturn new ").Append(dstFq).AppendLine("();");
            sb.AppendLine();
            sb.Append(indent).Append("var src = global::System.Runtime.InteropServices.CollectionsMarshal.AsSpan(source);").AppendLine();
            sb.Append(indent).Append("var target = new ").Append(dstFq).AppendLine("(src.Length);");
            sb.AppendLine();
            sb.Append(indent).Append("for (int i = 0; i < src.Length; i++)").AppendLine();
            sb.Append(indent).AppendLine("{");
            sb.Append(indent).Append("\tref readonly var s = ref src[i];").AppendLine();
            if (SymbolEqualityComparer.Default.Equals(sElem, dElem))
            {
                sb.Append(indent).Append("\ttarget.Add(s);").AppendLine();
            }
            else
            {
                string itemExpr = GetConversionExpression("s", sElem, dElem, names);
                sb.Append(indent).Append("\ttarget.Add(").Append(itemExpr).AppendLine(");");
            }
            sb.Append(indent).AppendLine("}");
            sb.Append(indent).AppendLine("return target;");
        }
        else if (srcIsArray)
        {
            sb.Append(indent).Append("if (source is null || source.Length == 0)").AppendLine();
            sb.Append(indent).Append("\treturn new ").Append(dstFq).AppendLine("();");
            sb.AppendLine();
            sb.Append(indent).Append("int n = source.Length;").AppendLine();
            sb.Append(indent).Append("var target = new ").Append(dstFq).AppendLine("(n);");
            sb.AppendLine();
            sb.Append(indent).Append("for (int i = 0; i < n; i++)").AppendLine();
            sb.Append(indent).AppendLine("{");
            if (SymbolEqualityComparer.Default.Equals(sElem, dElem))
            {
                sb.Append(indent).Append("\ttarget.Add(source[i]);").AppendLine();
            }
            else
            {
                string itemExpr = GetConversionExpression("source[i]", sElem, dElem, names);
                sb.Append(indent).Append("\ttarget.Add(").Append(itemExpr).AppendLine(");");
            }
            sb.Append(indent).AppendLine("}");
            sb.Append(indent).AppendLine("return target;");
        }
        else if (srcIsROList || srcIsIList)
        {
            sb.Append(indent).Append("if (source is null || source.Count == 0)").AppendLine();
            sb.Append(indent).Append("\treturn new ").Append(dstFq).AppendLine("();");
            sb.AppendLine();
            sb.Append(indent).Append("int count = source.Count;").AppendLine();
            sb.Append(indent).Append("var target = new ").Append(dstFq).AppendLine("(count);");
            sb.AppendLine();
            sb.Append(indent).Append("for (int i = 0; i < count; i++)").AppendLine();
            sb.Append(indent).AppendLine("{");
            if (SymbolEqualityComparer.Default.Equals(sElem, dElem))
            {
                sb.Append(indent).Append("\ttarget.Add(source[i]);").AppendLine();
            }
            else
            {
                string itemExpr = GetConversionExpression("source[i]", sElem, dElem, names);
                sb.Append(indent).Append("\ttarget.Add(").Append(itemExpr).AppendLine(");");
            }
            sb.Append(indent).AppendLine("}");
            sb.Append(indent).AppendLine("return target;");
        }
        else
        {
            // Fallback for non-indexable IEnumerable sources
            sb.Append(indent).Append("var target = new ").Append(dstFq).AppendLine("();");
            
            if (SymbolEqualityComparer.Default.Equals(sElem, dElem))
            {
                sb.Append(indent).Append("foreach (var item in source)").AppendLine();
                sb.Append(indent).Append("\ttarget.Add(item);").AppendLine();
            }
            else
            {
                sb.Append(indent).Append("foreach (var item in source)").AppendLine();
                sb.Append(indent).AppendLine("{");
                string itemExpr = GetConversionExpression("item", sElem, dElem, names);
                sb.Append(indent).Append("\ttarget.Add(").Append(itemExpr).AppendLine(");");
                sb.Append(indent).AppendLine("}");
            }
            
            sb.Append(indent).AppendLine("return target;");
        }
    }

    private static string GetConversionExpression(string expr, ITypeSymbol fromType, ITypeSymbol toType, NameCache names)
    {
        // Handle basic type conversions
        if (SymbolEqualityComparer.Default.Equals(fromType, toType))
            return expr;
            
        // Handle enum conversions
        if (fromType.TypeKind == TypeKind.Enum && Types.IsString(toType))
            return expr + ".ToString()";
            
        if (Types.IsString(fromType) && toType.TypeKind == TypeKind.Enum)
            return "GenAdapt_EnumParsers.Parse_" + San((INamedTypeSymbol)toType) + "(" + expr + ")";
            
        if (fromType.TypeKind == TypeKind.Enum && Types.IsInt(toType))
            return "(int)" + expr;
            
        if (Types.IsInt(fromType) && toType.TypeKind == TypeKind.Enum)
            return "(" + Types.Fq(toType) + ")" + expr;
            
        // Handle Guid conversions
        if (Types.IsGuid(fromType) && Types.IsString(toType))
            return expr + ".ToString()";
            
        if (Types.IsString(fromType) && Types.IsGuid(toType))
            return "global::System.Guid.TryParse(" + expr + ", out var g) ? g : default(global::System.Guid)";
            
        // Handle nullable conversions
        if (Types.IsNullableOf(fromType, out ITypeSymbol? fromInner) && Types.IsNullableOf(toType, out ITypeSymbol? toInner))
        {
            if (SymbolEqualityComparer.Default.Equals(fromInner!, toInner!))
                return expr; // same nullable type
        }
        
        // Handle user-defined type conversions
        if (fromType is INamedTypeSymbol fromNamed && toType is INamedTypeSymbol toNamed &&
            (fromNamed.TypeKind == TypeKind.Class || fromNamed.TypeKind == TypeKind.Struct) &&
            (toNamed.TypeKind == TypeKind.Class || toNamed.TypeKind == TypeKind.Struct) &&
            !Types.IsFrameworkType(fromNamed) && !Types.IsFrameworkType(toNamed))
        {
            string fromSan = names.Sanitized(fromNamed);
            string toSan = names.Sanitized(toNamed);
            if (fromNamed.TypeKind == TypeKind.Struct)
                return "Map_" + fromSan + "_To_" + toSan + "(in " + expr + ")";
            return "Map_" + fromSan + "_To_" + toSan + "(" + expr + ")";
        }
        
        // Default: cast
        return "(" + Types.Fq(toType) + ")" + expr;
    }

    private static string San(INamedTypeSymbol type)
    {
        // Simple sanitization for enum parser names
        return type.Name.Replace(".", "_").Replace("`", "_");
    }
}
